@implements IDialogContentComponent

@using CleanArch.eCode.HttpApi.Client.Identity
@using CleanArch.eCode.Shared.Notifications

@inject NotificationHttpService NotificationService

<FluentStack HorizontalAlignment="HorizontalAlignment.Right" Class="mb-2">
    <FluentCounterBadge BackgroundColor="@Color.Error" Color="Color.Fill">
        <FluentButton Appearance="Appearance.Neutral" OnClick="() => ToggleFilterAsync(false)">
            <FluentIcon Value="@(new Icons.Regular.Size20.List())" Color="@Color.FillInverse" />
        </FluentButton>
    </FluentCounterBadge>

    @if (unread > 0)
    {
        <FluentCounterBadge Count="@unread" BackgroundColor="@Color.Error" Color="Color.Fill">
            <FluentButton Appearance="Appearance.Neutral" OnClick="() => ToggleFilterAsync(true)">
                <FluentIcon Value="@(new Icons.Regular.Size20.Alert())" Color="@Color.FillInverse" />
            </FluentButton>
        </FluentCounterBadge>
    }

</FluentStack>

@foreach (var entry in notifications)
{
    var css = entry.MarkAsRead ? "" : "text-bg-secondary";
    css += " mb-2";

    <Card Class="@css">

        <FluentLabel Typo="Typography.H5">@entry.Title</FluentLabel>

        <div class="mt-2">
            @entry.Message
        </div>

        <div class="text-end">

            @if (!string.IsNullOrEmpty(entry.Url))
            {
                <a href="@entry.Url" target="_blank" @onclick="() => ReadEntryAsync(entry.Id)">Details</a>
            }
            else if (entry.MarkAsRead is false)
            {
                <a href="javascript:void(0)" @onclick="() => ReadEntryAsync(entry.Id)">Dismiss</a>
            }

        </div>

        <small class="float-end mt-1">@entry.CreatedOn</small>

    </Card>
}

@code {
    private IEnumerable<NotificationDto> notifications = Array.Empty<NotificationDto>();

    private NotificationLookup notificationByUser = new NotificationLookup();

    private int unread = 0;

    protected override async Task OnInitializedAsync()
    {
        await LoadNotificationsAsync();
    }

    private async Task LoadNotificationsAsync()
    {
        var userId = CurrentUser.UserId!;

        notificationByUser.ToUser = userId;

        var getNotifications = await NotificationService.GetAsync(notificationByUser);

        if (getNotifications.Succeeded)
        {
            notifications = getNotifications.Data;
            unread = await NotificationService.CountUnreadAsync(userId);
        }
    }

    private async Task ReadEntryAsync(string id)
    {
        await NotificationService.ReadAsync(id);
        await LoadNotificationsAsync();
    }

    private async Task ToggleFilterAsync(bool onlyUnread)
    {
        if (notificationByUser.OnlyUnread == onlyUnread)
        {
            return;
        }

        notificationByUser.OnlyUnread = onlyUnread;
        await LoadNotificationsAsync();
    }
}